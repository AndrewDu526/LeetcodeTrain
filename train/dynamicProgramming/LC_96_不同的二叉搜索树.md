## 1. Basic Information

- __level__: mid
- __completed-date__: 2-4-2026
- __status__: fail(hard)

## 2. Solution

注意根节点的变化，解释转载于评论：

例如当n = 4时，当1为根节点，其左边就没有节点，右边有3个节点，故当前二叉搜索树有dp[0] * dp[3]种
当2为根节点，其左边就有1个节点，右边有2个节点，故当前二叉搜索树有dp[1] * dp[2]种
当3为根节点，其左边就有2个节点，右边有1个节点，故当前二叉搜索树有dp[2] * dp[1]种
当4为根节点，其左边就有3个节点，右边有0个节点，故当前二叉搜索树有dp[3] * dp[0]种
最后我们就可以得到n =4时，搜索二叉树的种类共有dp[0] * dp[3] + dp[1] * dp[2] + dp[2] * dp[1] + dp[3] * dp[0]种

## 3. Code Implementation

    class Solution {
        public int numTrees(int n) {
            //初始化 dp 数组
            int[] dp = new int[n + 1];
            //初始化0个节点和1个节点的情况
            dp[0] = 1;
            dp[1] = 1;
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                    //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                    dp[i] += dp[j - 1] * dp[i - j];
                }
            }
            return dp[n];
        }
    }

## 4. Notes

- 只知道思路，没记住代码，二刷注意。

# LC 62 不同路径

## 1. Basic Information

- __level__: mid
- __time-cost__: n/a
- __completed-date__: 2-4-2026
- __completed-times__: 1
- __status__: fail

## 2. Solution

直接深度搜索会超时

## 3. Code Implementation

原始深度搜索（超时）

    class Solution {
    
        int count = 0;
    
        public int uniquePaths(int m, int n) {
            seek(m, n, 0, 0);
            return count;
        }
    
        public void seek(int m, int n, int mm, int nn){
            if(mm == m && nn = n) count++;return;
            if(mm > m || nn > n) return;
    
            seek(m, n, m++, n);
            seek(m, n, m, n++);
        }
    }

动态规划：
1. 定义dp数组：注意是dp[i][j]二维数组
2. 起初认为递归公式是dp[i][j] = dp[i-1][j-1] + 2，然而首先应该是*2（我将路径数和步数混淆了），其次终点的上一步是dp[i-1][j]或者dp[i][j-1]而不是dp[i-1][j-1]。
3. 数组初始化，注意到[0][i]和[j][0]都为1，直线一条路径

        public static int uniquePaths(int m, int n) {
            int[][] dp = new int[m][n];
            //初始化
            for (int i = 0; i < m; i++) {dp[i][0] = 1;}
            for (int i = 0; i < n; i++) {dp[0][i] = 1;}
            for (int i = 1; i < m; i++) {
                for (int j = 1; j < n; j++) {
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
            return dp[m-1][n-1];
        }

## 4. Notes

- 了解深度搜索的剪枝和记忆矩阵
- 注意终点是m-1，n-1

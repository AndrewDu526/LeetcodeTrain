# LC 202 快乐数

## 1. Basic Information

- __question__: 快乐数
- __topic__: hash
- __level__: easy
- __time-cost__: null
- __completed-date__: 12-22-2025
- __completed-times__: 1
- __status__: 阅读思路后写出，然代码设计不妥且有几处语法错误

## 2. Question

编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」 定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

示例 1：
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：
输入：n = 2
输出：false
 
提示：
1 <= n <= 231 - 1

## 3. Solution

从无限循环中可以注意到“重复元素”，一旦出现重复元素就说明不是快乐数。因此构造一个循环持续推到，直到结果为1或者出现重复。

## 4. Code Implementation
我的回答：

    class Solution {
      public boolean isHappy(int n) {
          if(n==1){return true;}
          Set<Integer> s = new HashSet();
          s.add(n);
          int mod = 0;
          // int sum = 0 之前在这里
          while(true){ // while(true) 设计不推荐
              int sum = 0;
              while(n>0){
                  mod = n % 10; // % 不更新n
                  sum += mod * mod; 
                  n = n / 10;
              }
  
              if(sum == 1){return true;}
  
              if(s.contains(sum)){
                  return false;
              }else{
                  s.add(sum);
                  n = sum;
              }
          }
      }
  }
  
- while(true)结构不稳定，不推荐
- 忘记int sum = 0 在while(true)初始化，导致sum累加，算法超时
- 不确定取模操作：mod = n % 10 不改变n值，需要手动n = n / 10 更新
标准答案：

  class Solution {
      public boolean isHappy(int n) {
          Set<Integer> record = new HashSet<>();
          while (n != 1 && !record.contains(n)) {
              record.add(n);
              n = getNextNumber(n);
          }
          return n == 1;
      }
  
      private int getNextNumber(int n) {
          int res = 0;
          while (n > 0) {
              int temp = n % 10;
              res += temp * temp;
              n = n / 10;
          }
          return res;
      }
  }
  
## 5. Conclusion
- 注意取模操作
- 使用更专业的循环结构
- 注意无限循环意味着检测重复元素

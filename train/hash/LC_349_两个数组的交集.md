# LC 349 两个数组的交集

## 1. Basic Information

- __question__: 两个数组的交集
- __topic__: hash
- __level__: easy
- __time-cost__: null
- __completed-date__: 12-22-2025
- __completed-times__: 1
- __status__: 查看思路和代码后写出

## 2. Question

给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

提示：
1 <= nums1.length, nums2.length <= 1000

## 3. Solution

通过转化成java的HashSet的contain方法避免遍历。先将一个数组转变成HashSet，然后将第二个数组的元素和HashSet的元素用contains方法逐个比较，将重复的元素保存到一个新的HashSet后转换成数组输出。

## 4. Code Implementation

    class Solution {
          public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet();
        Set<Integer> union  = new HashSet();

        for(int i : nums1){
            set1.add(i); 
            // autoboxing java自动转型，手动转型则Integer.valueOf(int)
            // java HashSet 不会对重复元素报错，但返回false并不实际增加
        }

        for(int i : nums2){
            if(set1.contains(i)){ // contains不需要遍历，因为HashSet的本质是Key值为元素的HashMap，利用hash
                union.add(i);
            }

        }

        int[] result = new int[union.size()];
        int j = 0;
        for(Integer i : union){
            result[j] = i; //手动转型i.intValue()
            j++; 
        }

        return result;
        }
    }



## 5. Conclusion

- HashSet的add方法不会对重复元素报错，方法会返回false同时并不会加入重复元素，因此语法上不报错。
- HashSet的contains方法底层使用HashMap实现，因为使用hash映射时间复杂度为O(1)。
- Integer 和 int 能直接自动转型。

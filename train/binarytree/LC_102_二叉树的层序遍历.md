# LC 102 二叉树的层序遍历

## 1. Basic Information

- __level__: medium
- __time-cost__: 未计时
- __completed-date__: 1-1-2026
- __completed-times__: 1
- __status__: 看思路和代码完成

## 2. Solution

使用递归法和队列法；
递归法重点在于增加result当小于深度，且直接操作数组下标；递归维护一个深度，确保同层节点都位于同一个深度。
队列法重点在于维护一个queue，while循环保证不为空，内部嵌套for/while循环计数遍历一层的元素。

## 3. Code Implementation

    class Solution {
    
        List<List<Integer>> result = new ArrayList<>();
    
        public List<List<Integer>> levelOrder(TreeNode root) {
            // travel01(root);
            travel02(root, 0);
            return result;
        }
    
        private void travel01(TreeNode node){
            if(node == null){return;}
            Queue<TreeNode> que = new ArrayDeque<>();
            que.offer(node);
    
            while(que.size()>0){
                int len = que.size();
                List<Integer> level = new ArrayList<>();
                while(len>0){
                    TreeNode n = que.poll();
                    level.add(n.val);
                    if(n.left!=null){que.offer(n.left);}
                    if(n.right!=null){que.offer(n.right);}
                    len--;
                }
    
                result.add(new ArrayList<>(level));
            }
        }
    
        private void travel02(TreeNode node, int deep){
            if(node == null){return;}
    
            deep++;
    
            if(result.size()<deep){
                result.add(new ArrayList<>());
            }
    
            result.get(deep-1).add(node.val);
    
            travel02(node.left, deep);
            travel02(node.right, deep);
        }
    }

## 4. Notes

# LC 654 最大二叉树

## 1. Basic Information

- __level__: medium
- __time-cost__: 未计时
- __completed-date__: 1-14-2026
- __completed-times__: 1
- __status__: 独立完成

## 2. Solution

找到最大值，对左右区间递归构造

## 3. Code Implementation

    class Solution {
        public TreeNode constructMaximumBinaryTree(int[] nums) {
            return build(nums, 0, nums.length);
        }
    
        private TreeNode build(int[] nums, int left, int right){
            if(left >= right){return null;}
    
            int head = find(left, right, nums);
            TreeNode node = new TreeNode(nums[head]);
            node.left = build(nums, left, head);
            node.right = build(nums, head+1, right);
    
            return node;
        }
    
        private int find(int head, int tail, int[] nums){
            int idx = head;
            for (int i = head + 1; i < tail; i++) {
                if (nums[i] > nums[idx]) idx = i;
            }
            return idx;
        }
    }

## 4. Notes

- 不需要排序

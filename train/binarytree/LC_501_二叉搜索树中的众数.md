# LC 501 二叉搜索树中的众数

## 1. Basic Information

- __level__: easy
- __time-cost__: 未计时
- __completed-date__: 1-14-2026
- __completed-times__: 1
- __status__: 不会

## 2. Solution

先视作有序数组，在中序遍历中递归，双指针比较前后两个节点，维护一个众数列表和最大值，累计等于最大值就加入列表，若超过最大值就更新最大值并清空众数列表加入此众数。

## 3. Code Implementation

    class Solution {
    
        List<Integer> result = new ArrayList<>();
        TreeNode prev = null;
        int count = 0;
        int maxCount = 0;
    
        public int[] findMode(TreeNode root) {
            find(root);
            int[] answer = new int[result.size()];
            for(int i=0;i<result.size();i++){
                answer[i] = result.get(i);
            }
            return answer;
        }
    
        private void find(TreeNode node){
            if(node == null) return;
            find(node.left);
            if(prev == null || prev.val != node.val){
                count = 1;
            }else{
                count ++;
            }
            if(count == maxCount){
                result.add(node.val);
            }else if(count > maxCount){
                result.clear();
                result.add(node.val);
                maxCount = count;
            }
            prev = node;
            find(node.right);
        }
    }

## 4. Notes

- 仍然 二叉搜索树 = 有序数组

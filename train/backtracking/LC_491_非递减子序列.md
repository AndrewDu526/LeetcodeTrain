# LC 491 非递减子序列

## 1. Basic Information

- __level__: medium
- __time-cost__: 未计时
- __completed-date__: 12-27-2025
- __completed-times__: 1
- __status__: 在去重提示下，几乎独立完成

## 2. Solution

收录所有节点（长度大于等于2），遍历时跳过比上一个数小的元素；由于要保留顺序不能排序，因此每一层维护一个set去重。

## 3. Code Implementation

    class Solution {
    
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> node = new ArrayList<>();
    
        public List<List<Integer>> findSubsequences(int[] nums) {
            
            backtracking(nums, 0);
            return result;
        }
    
        private void backtracking(int[] nums, int index){
            Set<Integer> layer = new HashSet<>();
    
            if(node.size()>=2){
                result.add(new ArrayList<>(node));
            }
    
            for(int i=index;i<nums.length;i++){
    
                if(layer.contains(nums[i])){
                    continue;
                }else{
                    layer.add(nums[i]);
                }
                
    
                if(node.size()>0 && nums[i]>=node.get(node.size()-1)){
                    node.add(nums[i]);
                    backtracking(nums,i+1);
                    node.remove(node.size()-1);
                }else if(node.size()==0){
                    node.add(nums[i]);
                    backtracking(nums,i+1);
                    node.remove(node.size()-1);
                }
            }
        }
    }

## 4. Notes

- 注意不得排序，每层维护一个set去重。
- 注意处理首次加入元素，原node为空的情况

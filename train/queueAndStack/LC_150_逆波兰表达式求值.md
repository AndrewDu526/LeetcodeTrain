# LC 150 逆波兰表达式求值

## 1. Basic Information

- __question__: 逆波兰表达式求值
- __topic__: stack
- __level__: medium
- __time-cost__: null
- __completed-date__: 12-24-2025
- __completed-times__: 1
- __status__: 我认为可以倒序递归未尝试，查看“完整”思路后实现

## 2. Question

给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
注意：
有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。
 
示例 1：
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
 

提示：
1 <= tokens.length <= 104
tokens[i] 是一个算符（"+"、"-"、"*" 或 "/"），或是在范围 [-200, 200] 内的一个整数

逆波兰表达式：
逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

## 3. Solution

遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

## 4. Code Implementation

    class Solution {
        public int evalRPN(String[] tokens) {
            Deque<Integer> deq = new ArrayDeque<>();
            int d1;
            int d2;
            for(String token : tokens){
                switch(token){
                    case "+": 
                        d1 = deq.pollFirst();
                        d2 = deq.pollFirst();
                        deq.offerFirst(d1+d2);
                        break;
                    case "-": 
                        d1 = deq.pollFirst();
                        d2 = deq.pollFirst();
                        deq.offerFirst(d2-d1);
                        break;
                    case "/": 
                        d1 = deq.pollFirst();
                        d2 = deq.pollFirst();
                        deq.offerFirst(d2/d1);
                        break;
                    case "*": 
                        d1 = deq.pollFirst();
                        d2 = deq.pollFirst();
                        deq.offerFirst(d1*d2);
                        break;
                    default:
                        deq.offerFirst(Integer.parseInt(token));
                }
            }
            return deq.pollFirst();
        }
    }

## 5. Conclusion

- 典型的一题一解，记住题解思路就行
- String 转 int 使用 Integer.parseInt(str)
- 由于用栈，除法和减法需要颠倒顺序
- 注意switch-case语法：switch{ case: ...} 每个case必须有break;否则会继续执行之后的cases
